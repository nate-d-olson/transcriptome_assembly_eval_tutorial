---
title: "Trinity and Transrate Tutorial"
author: "Nate Olson & Leann Biancani"
date: "May 2, 2016"
output: github_document
bibliography: tutorial.bib 
---
```{r setup, warning=FALSE, message=FALSE, echo = FALSE}
library(knitr)
library(readr)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(ggplot2)
library(GGally)
```

```{r source_dir, warning=FALSE, message=FALSE, echo = FALSE}
results_list <- list(
      no_mods = "data/no_mods/Trinity_sequences.Trinity.fixed/",
      corrected = "data/corrected/Assembly4_Corrected.Trinity.fixed/",
      trimmed = "data/trimmed/Assembly2_Trimmed.Trinity.fixed/",
      trimmedcorrected = "data/trimmedcorrected/Assembly3_TrimmedCorrected.Trinity.fixed/"
)
```

## Background 

#### Transcriptome
* RNAseq & transcriptomics [@Wang:2009di]  

#### De novo Transcriptome assembly
* Variation in assemblies - same read data can generate very different assemblies [@smith2015transrate]  
      * within assembly method: many parameters & heuristics (to accommodate variation in library construction, coverage depth, organisms)
      * between assembly methods: many different appraochs to assembly problem  
            - Oases (Schulz et al. 2012 - not in bib yet)  
            - SOAPdenovo-Trans (Xie et al. 2014 - not in bib yet)  
            - Trinity [@Grabherr:2011jb, @haas2013novo]
            
#### Transcriptome assembly evaluation  

* Reference based
* Read based
* Transrate - contig level quality score [@smith2015transrate]

#### C. elegans transcriptome assembly and evaluation (what we did)

## Assembly
### Source data  
Sequence data identified by searching SRA for _C. elegans_ and limiting results to RNA, identified a study for an Illumina HiSeq 2000, 94 bp paired end run. Accession SRR2969230 was used to generate and evaluate the assembly.

> 
Caenorhabditis elegans Transcriptome or Gene expression BioProject
Abstract: Insulin/IGF-1 signaling (IIS) is a critical regulator of the most important biological decisions, from rates of growth, development, and metabolism, to reproduction and longevity. However, the neuron-specific IIS/FOXO targets that regulate these functions are still unknown. By isolating C. elegans neurons for transcriptional profiling, we identified both the wild-type and IIS/FOXO neuronal transcriptomes. Here we deposit the sequences for wt adult neurons and IIS mutants, as well as for isolated adult mechanosensory neurons.

Relevant _C. elegans_ Reference Sequences  

* Transcriptome: ftp://ftp.ensemblgenomes.org/pub/release-31/metazoa/gtf/caenorhabditis_elegans/Caenorhabditis_elegans.WBcel235.31.gtf.gz   
* Genome: ftp://ftp.ensemblgenomes.org/pub/release-31/metazoa/fasta/caenorhabditis_elegans/dna/Caenorhabditis_elegans.WBcel235.31.dna.chromosome.*.fa.gz   
* Proteome: ftp://ftp.ensemblgenomes.org/pub/release-31/metazoa/fasta/caenorhabditis_elegans/pep/Caenorhabditis_elegans.WBcel235.31.pep.all.fa.gz    

### How to run trinity  
* Link to website  
* Parameter description
* Command used to generate _C. elegans_ assembly

### Assembly results  
Assembly metrics calculated using Transrate, see http://hibberdlab.com/transrate/metrics.html for a description of the different metrics.  
__Metrics__
* n_seq - number of contigs in the assembly  
* smallest - size of the shortest contig (bp)  
* largest - size of the longest contig (bp)  
* n50 - largest contig size at which at least 50% of bases are contained in contigs at least this length.
* n_with_orf - number of contigs with a open reading frame  

```{r}
assembly_metrics_df <- list(no_mods = "data/no_mods/", 
                            corrected = "data/corrected/",
                            trimmed = "data/trimmed/", 
                            trimmedcorrected = "data/trimmedcorrected/") %>% 
      map(paste0, "assemblies.csv") %>%  
      map_df(read_csv, .id = "read_set") %>% 
      select(-assembly) %>% 
      gather("metric","value", -read_set) %>% 
      mutate(read_set = factor(read_set, levels = c("no_mods","corrected","trimmed","trimmedcorrected")))
```




```{r}
assembly_metrics_df %>% 
      filter(metric %in% c("n_seqs", "smallest", "largest", 
                           "n50", "n_with_orf")) %>%
      spread(metric, value) %>% 
      select(read_set, n_seqs, smallest, n50, largest, n_with_orf) %>% 
      kable(digits = 2,
            caption = "Trinity _C. elegans_ transcriptome assembly summary metrics.")
```

## Assembly evaluation
### Running transrate
* Installation
      * Precompiled binaries available from website (http://hibberdlab.com/transrate/), along with instructions to build from source
      * also command to install dependencies `transrate --install-deps type` where type can be either `all`, `read`, or `ref`.
      * See Transrate website for additional information for install. 


__Command Line__  
Correcting transcript IDs

_Read Based_

```
transrate \
  --left=SRR2969230_1.fastq \
  --right=SRR2969230_2.fastq \
  --assembly=Trinity_sequences.Trinity.fixed.fasta \
  --output=transrate/
```

_Reference Based_
```
transrate \
  --reference=Caenorhabditis_elegans.WBcel235.31.pep.all.fa \
  --assembly=Trinity_sequences.Trinity.fixed.fasta \
  --output=transrate/
```

### Transrate results
The unmodified read set was passed as input to Transrate, 
potentally biasing some metric results towards the unmodifed assembly.

#### run time
__TODO__ Add runtime for other assemblies and reference based evaluations  

- real    890m58.016s
- user    6665m50.869s
- sys     11m5.890s

#### Assembly Scores
Read trimming and error correction resulted in the highest weighted assembly score, 
while having the lowest contig score cutoff, 
but a lower optimal score.  

Weighted assembly score - takes into consideration expression level, generous to assemblies with high proportions of low expressed poorly assembled contigs.

```{r}
assembly_metrics_df %>% 
      filter(metric %in% c("score", "optimal_score", "cutoff", "weighted")) %>%
      spread(metric, value) %>% 
      kable(digits = 2,
            caption = "Trinity _C. elegans_ transcriptome Transrate score summary.")
```


#### Assembly Score Optimization
```{r}
assembly_score_opt <- results_list %>% map(paste0,"assembly_score_optimisation.csv") %>% 
      map_df(read_csv, .id = "read_set") %>% 
      mutate(read_set = factor(read_set, levels = c("no_mods","corrected","trimmed","trimmedcorrected")))
```

Relationship between the cutoff for contig score and assembly score.
```{r}
assembly_score_opt %>% 
      ggplot() + geom_path(aes(x = cutoff, y = assembly_score, color = read_set)) +
            theme_bw() +
            labs(x = "Contig Score Threshold", y = "Assembly Score")
```

### Contigs
see contigs.rb and read_metrics.rb for additional information about metrics
   def score
      return @score if @score != -1
      prod =
        [p_bases_covered, 0.01].max.to_f * # proportion of bases covered
        [p_not_segmented, 0.01].max.to_f * # prob contig has 0 changepoints
        [p_good, 0.01].max.to_f * # proportion of reads that mapped good
        [p_seq_true, 0.01].max.to_f # scaled 1 - mean per-base edit distance
      @score = [prod, 0.01].max
Contig Score
> 
There are four components to the contig score:
1. A measure of whether each base has been called correctly. This is estimated using the mean per-base edit distance, i.e. how many changes would have to be made to a read covering a base before the sequence of the read and the covered region of the contig agreed perfectly.
2. A measure of whether each base is truly part of the transcript. This is estimated by determining whether any reads provide agreeing coverage for a base.
3. The probability that the contig is derived from a single transcript (rather than pieces of two or more transcripts). This is measured as the probability that the read coverage is best modelled by a single Dirichlet distribution, rather than two or more distributions.
4. The probability that the contig is structurally complete and correct. This is estimated as the proportion of assigned read pairs that agree with the structure and composition of the contig, which in turn is calculated by classifying the read pair alignments.

```{r}
contig_stat <- results_list %>% map(paste0,"contigs.csv") %>% 
      map_df(read_csv, .id = "read_set")

contig_cutoff <- assembly_metrics_df %>% filter(metric == "cutoff") %>% 
      select(-metric) %>% rename(cutoff = value)
contig_stat <- contig_stat %>% left_join(contig_cutoff) %>% 
      mutate(contig_filt = cutoff < score)
```


__Contig Score Distribution__
Trimming reads resulted in a higher proportion of contigs with scores greater than 0.25 then assemblies using unmodified reads or only error corrected reads.  

```{r}
contig_stat %>% 
      ggplot() + geom_density(aes(x = score, color = read_set, fill = read_set), 
                              alpha = 0.25) + theme_bw()
```


Relationship between contig score and length. 
```{r score_length, fig.cap = "2D histogram of contig score and legnth, with color indicating abundance. Grey dotted lines are the contig score cutoff for optimal assembly score."}
contig_stat %>% 
      ggplot() + geom_hex(aes(x = length, y = score)) +
            geom_hline(aes(yintercept = cutoff), 
                       color = "grey60", linetype = 2) +
            theme_bw() +
            labs(x = "Contig Length (bp)", y = "Contig Score") +
            facet_wrap(~read_set)
```

Proportion of bases in reads map to the transcript that support the transcript contig. 

```{r p_good_density, fig.cap = "Histogram of the proportion of bases in agreement with contig and contig length."}
contig_stat %>% 
      ggplot() + geom_histogram(aes(x = p_good)) +
            theme_bw() +
            labs(x = "Proportion of Bases Aggree with Transcript",
                 y = "Count") +
            facet_grid(contig_filt~read_set) +
            theme(legend.position = "bottom")
```

Proportion of bases in the contig covered, at least one read aligned to the contig coverage that position.

```{r}
contig_stat %>% 
      ggplot() + geom_histogram(aes(x = p_bases_covered)) +
            theme_bw() +
            labs(x = "Proportion of Covered Bases", 
                 y = "Count") +
            facet_grid(contig_filt~read_set) +
            theme(legend.position = "bottom")
```


Mean per-base contig edit distance, average number of base pair differences between contig and reads.
```{r}
contig_stat %>% 
      ggplot() + geom_histogram(aes(x = p_seq_true)) +
            theme_bw() +
            labs(x = "Mean Per-Base Edit Distance", 
                 y = "Count") +
            facet_grid(contig_filt~read_set) +
            theme(legend.position = "bottom")
```

Probability that a contig is not a chimeric misassembly, 
where sequences from two different contigs are incorrectly assembled together.
```{r}
contig_stat %>% 
      ggplot() + geom_histogram(aes(x = p_not_segmented)) +
            theme_bw() +
            labs(x = "Proportion of Non-Segmented Contigs", 
                 y = "Count") +
            facet_grid(contig_filt~read_set) +
            theme(legend.position = "bottom")
```

The individual parameters used to calculate the contig score are weakly correlated. 
Correlation values are similar to thoes presented in the Transrate publication. 

```{r}
for(i in names(results_list)){
      pl <- contig_stat %>% filter(read_set == i) %>% 
            select(p_good, p_bases_covered, p_seq_true, p_not_segmented) %>% 
            ggcorr(method = c("pairwise","spearman"),label = TRUE) + 
                  ggtitle(i)
      print(pl)
}
```

#### Reference Based Results
__TODO__ Describe CRB method

```{r source_ref_dir, warning=FALSE, message=FALSE, echo = FALSE}
results_list <- list(
      no_mods = "data/no_mods_ref/Trinity_sequences.Trinity.fixed/",
      corrected = "data/corrected_ref/Assembly4_Corrected.Trinity.fixed/",
      trimmed = "data/trimmed_ref/Assembly2_Trimmed.Trinity.fixed/",
      trimmedcorrected = "data/trimmedcorrected_ref/Assembly3_TrimmedCorrected.Trinity.fixed/"
)
```

```{r}
ref_contig <- results_list %>% map(paste0,"contigs.csv") %>% 
      map_df(read_csv, .id = "read_set")
```

__TODO__Summary table
with assembly, p contigs with CRBB (proportion of contigs iwth CRB-Blast), p_ref crbb proprotion ref with CRBB, ref coverage - proportion of reference bases covered by CRB hits, collapse factor - high chimeras, p covX - proportion protein coverage, 
Comprison of contigs with and with out CRB hits. Assemblies using untrimmed read set had a larger number of contigs, but little impact of the proportion of CRB hits.
```{r}
ggplot(ref_contig) + geom_bar(aes(x = read_set)) + facet_wrap(~has_crb)
```

Comprison of contig length and ORF length for contigs with and without CRB hits. 
Contigs with CRB hits were long and contined larger predicted ORFs.  

```{r}
ggplot(ref_contig) + geom_boxplot(aes(x = has_crb, y = length)) + facet_wrap(~read_set)
```

```{r}
ggplot(ref_contig) + geom_boxplot(aes(x = has_crb, y = orf_length)) + facet_wrap(~read_set)
```

Exploring contigs with CRB hits.  
```{r}
crb_contig <- ref_contig %>% filter(has_crb == "true")
```

```{r}
ggplot(crb_contig) + geom_hex(aes(x = length, y = reference_coverage)) + 
      facet_wrap(~read_set)
```

```{r}
ggplot(crb_contig) + geom_hex(aes(x = orf_length, y = reference_coverage)) +
      facet_wrap(~read_set)
```


### Contig Score and Hit Coverage
```{r}
contig_crb_score <- crb_contig %>% left_join(contig_stat)
```

__TODO__ Better way to present relationship
```{r}
ggplot(contig_crb_score) + 
      geom_hex(aes(x = reference_coverage, y = score)) +
      facet_wrap(~read_set)
```

__TODO__
Upper limit? correlation between reference coverage and score
Looking at tpm 


## Conclusions
* How did Trinity do?
* How did transrate compare to other methods?
* Recommendations for transcriptome assembly and evaluation

## Session Information
__Session Info__
```{r s_info}
s_info <- devtools::session_info()
print(s_info$platform)
kable(s_info$packages)
```
## References
